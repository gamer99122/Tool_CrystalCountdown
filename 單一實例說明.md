# 單一實例功能說明

## 🎯 功能概述

當你重複執行 DesktopAnnouncement.exe 時，程式會**自動關閉舊的實例**並啟動新的，確保只有一個實例在運行。

---

## ✨ 為什麼需要這個功能？

### 問題場景
```
❌ 沒有單一實例功能：
1. 第一次執行 → 程式啟動
2. 第二次執行 → 又啟動一個，現在有兩個視窗
3. 第三次執行 → 再啟動一個，現在有三個視窗
4. 結果：桌面混亂，記憶體浪費
```

### 解決方案
```
✅ 有單一實例功能：
1. 第一次執行 → 程式啟動
2. 第二次執行 → 自動關閉第一個，啟動新的
3. 第三次執行 → 自動關閉第二個，啟動新的
4. 結果：永遠只有一個視窗
```

---

## 🔧 技術實作

### 核心機制：Mutex（互斥鎖）

```csharp
// 建立全域互斥鎖
const string mutexName = "Global\\DesktopAnnouncement_SingleInstance_Mutex";
_mutex = new Mutex(true, mutexName, out bool createdNew);

if (!createdNew)
{
    // 已有實例在執行，關閉舊實例
    TerminateExistingInstance();
}
```

### 執行流程

```
[啟動程式]
    ↓
[嘗試建立 Mutex]
    ↓
[Mutex 已存在？]
    │
    ├─ 否 → [首次執行，正常啟動]
    │
    └─ 是 → [找到舊實例]
           → [終止舊實例]
           → [等待 500ms]
           → [重新建立 Mutex]
           → [啟動新實例]
```

---

## 📋 使用場景

### 場景 1：誤點兩次
```
問題：不小心雙擊執行檔
結果：自動關閉第一個，只保留最新的
```

### 場景 2：更新設定後重啟
```
問題：修改 config.txt 後想重新載入
操作：直接再執行一次 .exe
結果：自動關閉舊的，啟動新的（載入新設定）
```

### 場景 3：開機自動啟動 + 手動執行
```
問題：設定了開機啟動，但又手動執行了一次
結果：自動關閉開機啟動的，保留手動執行的
```

---

## 🧪 測試方法

### 方法 1：使用測試腳本（推薦）

```bash
# 執行測試腳本
test_single_instance.bat
```

腳本會自動：
1. 啟動第一個實例
2. 檢查實例數量
3. 啟動第二個實例
4. 再次檢查實例數量
5. 顯示測試結果

### 方法 2：手動測試

```bash
# 1. 執行第一次
DesktopAnnouncement.exe

# 2. 打開工作管理員，確認只有一個實例

# 3. 再執行一次
DesktopAnnouncement.exe

# 4. 再次檢查工作管理員，應該還是只有一個實例
```

### 方法 3：使用指令測試

```bash
# 啟動程式
start DesktopAnnouncement.exe

# 等待 3 秒
timeout /t 3

# 再次啟動
start DesktopAnnouncement.exe

# 檢查運行中的實例數量
tasklist | find /c "DesktopAnnouncement.exe"
```

---

## 💡 技術細節

### Mutex 名稱
```
Global\\DesktopAnnouncement_SingleInstance_Mutex
```
- `Global\\`：跨使用者會話（即使不同使用者也視為同一實例）
- 唯一性：確保整個系統只有一個 Mutex

### 終止舊實例的邏輯

```csharp
private void TerminateExistingInstance()
{
    // 1. 取得當前處理程序資訊
    var currentProcess = Process.GetCurrentProcess();

    // 2. 找到所有同名處理程序（排除自己）
    var existingProcesses = Process.GetProcessesByName(currentProcessName)
        .Where(p => p.Id != currentProcessId);

    // 3. 逐一終止
    foreach (var process in existingProcesses)
    {
        process.Kill();
        process.WaitForExit(2000); // 等待最多 2 秒
    }
}
```

### 等待時間
```csharp
Thread.Sleep(500); // 等待 500ms 確保舊實例完全關閉
```

---

## ⚠️ 注意事項

### 1. 位置儲存
當舊實例被關閉時：
- ✅ 位置會被保存到 `position.txt`
- ✅ 新實例會讀取並使用該位置

### 2. 正在拖動時
如果你正在拖動視窗時重複執行：
- 舊實例會被立即終止
- 新實例會在上次儲存的位置顯示

### 3. 多使用者環境
由於使用 `Global\\` Mutex：
- 不同使用者登入同一台電腦
- 也會視為同一實例（只能有一個在運行）

如果希望每個使用者都能獨立運行，可修改為：
```csharp
const string mutexName = "Local\\DesktopAnnouncement_SingleInstance_Mutex";
```

---

## 🆚 版本比較

| 功能 | v1.1 (舊版) | v1.2 (新版) |
|------|-------------|-------------|
| 允許多個實例 | ✅ | ❌ |
| 重複執行時的行為 | 開啟新實例 | 關閉舊實例並啟動新的 |
| Mutex 保護 | ❌ | ✅ |
| 自動清理舊實例 | ❌ | ✅ |

---

## 🐛 疑難排解

### Q: 無法啟動第二個實例？
A: **這是正常行為！** 單一實例功能會自動關閉舊的並啟動新的。

### Q: 如何允許多個實例？
A: 修改 `App.xaml.cs`，註解掉 Mutex 相關程式碼：
```csharp
// 註解掉這些行
// _mutex = new Mutex(true, mutexName, out createdNew);
// if (!createdNew) { ... }
```

### Q: 程式無法啟動？
A: 檢查是否有其他處理程序持有 Mutex。重新開機通常可以解決。

### Q: 關閉舊實例時會遺失資料嗎？
A: 不會，視窗位置會在 `LocationChanged` 事件中即時儲存。

---

## 📝 程式碼位置

主要實作在 `App.xaml.cs`：
- 第 14-17 行：Mutex 宣告
- 第 24-41 行：單一實例檢查
- 第 74-107 行：終止舊實例邏輯
- 第 112-119 行：退出時釋放 Mutex

---

## 🚀 未來改進

- [ ] 新增選項：允許/禁止多實例
- [ ] 新增通知：告知使用者舊實例已關閉
- [ ] 新增命令列參數：`--allow-multiple` 允許多實例
- [ ] 改進：使用 IPC 通知舊實例優雅關閉，而非強制 Kill

---

## 📞 回饋

如有問題或建議，歡迎回饋！
